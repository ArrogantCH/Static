# 四 引用折叠、转发、完美转发、forward

## 一 引用折叠 规则

引用折叠，c++新标准，是一条规则

```c++
//void myfunc(int& &&tmprv) //两组，第一组int&,左值引用，第二组 &&tmprv，实际是右值引用个类型
//分成两组的， 第一组：左值引用/右值引用   第二组：左值引用/右值引用
//左值引用 -- 左值引用	&	&
//左值引用 -- 右值引用	&	&&
//右值引用 -- 左值引用	&&	&
//右值引用 -- 右值引用	&&	&&

//折叠规则： 如果任意一个引用为左值引用，那么几个就为左值引用，否则就是右值引用
//	&
//	&
//	&
//	&&
```

### 1.1 引用的引用

```c++
int b = 500;
int &byi = b; //byi是b的引用
// int & &byy = byi; //非法，byy是byi的引用，引用的引用
// 编译器不允许程序开发者直接写出引用的引用这种形式的代码

//需要折叠规则的场景： 函数模板实例化，auto
```

## 二 转发、完美转发

```c++
int &&a = 80; //右值引用绑定右值
						//虽然 &&a是绑定到右值的，但是a本身是个左值，因为a是在等号左边待着的
						//也就是说，左值引用或者右值引用这种概念，说的是a的类型，而不是a本身
void ft(int &&w); //形参总是左值，w总是左值，即使它的额类型是右值引用
```

```c++
template<typename F, typename T1, typename T2>
//void myFuncTemp(F f, T1 t1, T2 t2) //F就是第三方我们要调用的函数，就是要转发到的目标函数
void myFuncTemp(F f, T1 &&t1, T2 &&t2) //F就是第三方我们要调用的函数，就是要转发到的目标函数
{
	//f(t1, t2);
	f(std::forward<T1>(t1), std::forward<T2>(t2));
}

void myfunc(int v1, int &v2)
{
	++v2;
	std::cout << v1 + v2 << std::endl;
}
```

### std::forward：

c++11新函数，专门为转发而存在。要么返回一个左值，要么返回一个右值

发挥作用的条件：调用模板函数，模板函数参数是万能引用类型，模板函数负责转发

std::forward 就是按照参数本来的类型转发, 保持原始实参的类型(左值/右值)