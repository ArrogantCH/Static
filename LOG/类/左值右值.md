# 左值右值

## 一 左值和右值

```c++
int i = 10; //对象：一块内存区域
i = 20;
```

左值： 能用在赋值语句等号左侧的东西，它能够代表 一个地址

右值：“不能作为左值的值就是右值”，右值不能出现在赋值语句中等号的左侧

**结论：**

c++中的一条表达式，要么就是左值，要么就是右值，不可能两者都不是

```c++
//左值有的时候能够被当做右值使用
i = i + 1; //i是个左值，不是个右值，虽然它出现在了等号右边
//i用在等号右边的时候，我们说i有一种右值属性（不是右值）
//i出现在等号左边，用的是i代表的内存中的地址，我们说i有一种左值属性
//一个左值 它可能同时具有左值属性和右值属性
```

用到左值的运算符有哪些：

（a）赋值运算符

```c++
int a;
//整个赋值语句的结果仍然是个左值
(a = 4) = 8;
```

（b）取地址 &

```c++
int a = 5; //变量就是个左值
&a;
```

（c）string,vector 下标[]都需要左值；迭代器

```c++
std::string abc = "I love China";
abc[0];
std::vector<int>::iterator iter;
iter++; iter--; //9-- 非法
```

（d）通过看一个运算符在一个字面值上能不能操作，我们就可以判断运算符是否用都的是左值

```c++
i++;
//5++;
```

左值表达式 就是左值，右值表达式 说的就是右值

左值：代表一个地址，所以左值表达式的求值结果，就得是 一个对象，就得有地址

求值结果为对象的表达式，不代表一定是左值，具体再分析

100 它显然是个右值

## 二 引用分类

```c++
int value = 10;
int &refval = value;
refval = 13;
```

三种形式引用

（1）左值引用（绑定到左值）

（2）const引用（常量引用），也是左值引用。我们不希望改变值的对象

```c++
const int &refval2 = value;
```

（3）右值引用（绑定到右值）：它是个引用

```c++
int &&refrightvalue = 3; //绑定到一个常量
refrightvalue = 5;
```

## 三 左值引用

```c++
//引用左值，绑定到左值上
char *p = nullptr; //指针有空指针的说法
//没有空引用的说法，所以左值引用初始化的时候就绑定左值

int a = 1;
int &b{ a }; //b绑定到a
int &c; //错误，引用必须要初始化
int &c = 1; //错误，左值引用不能帮到到右值，必须绑定到左值


const int &c = 1; //const引用可以绑定到右值，所以const引用特殊
//等价于系统给创建了一个临时变量
int tmpvalue = 1; //临时变量
const int &c = tmpvalue;
```

## 四 右值引用

就是引用右值，也就是说，绑定到右值，必须是绑定到右值的引用

 &&, 希望用右值引用来绑定一些即将销毁的或者是一些临时的对象上

右值引用 也是 引用

```c++
int &&refrightvalue = 3; //右值引用理解为一个对象的名字，它也有地址
refrightvalue = 5;

//能绑定到左值上去的引用，一般不能绑定到右值
int value = 10;
int &&refrightvalue = value; //右值引用也帮不到左值上

std::string strtest{ "I love China" };
std::string &r1{ strtest }; //可以，左值引用绑定左值
std::string &r2{ "I love China" }; //不可以，左值引用不能绑定到临时变量。临时变量被系统当做右值
const std::string &r3{ "I love China" }; //可以，创建个临时变量，绑定到左值r3上去
//const引用不但可以绑定到右值，还可以执行到string的隐式类型转换并将所得到的值放倒string临时变量中去
std::string &&r4{ strtest }; //不可以，右值引用不能绑定到左值
std::string &&r5{ "I love China" }; //可以，绑定到一个临时变量

int &&r3 = i * 100; // 可以，右值引用绑定到右值
int &r4 = i * 100; //不可以，左值引用不能绑定到右值
const int &r6 = i * 100; //可以，绑定到右值
```

**总结：**

返回左值引用的函数，连同**赋值，下标，解引用和前置递增递减运算符（--i）**,都是返回左值表达式的例子；我们可以将一个左值引用绑定到这类表达式结果上

返回非引用类型的函数，连同**算数，关系，位以及后置递增递减运算符（i--）**,都生成右值，不能将一个左值引用绑定到这类表达式上，但是我们可以将一个const引用和右值引用绑定到这类表达式上

```c++
++i; //左值表达式。 ++i之间给变量i+1，然后返回i本身
int i = 100;
(++i) = 199; //i被赋值成199了、
```

```c++
i++; //先用后加， 为什么是右值表达式
	//i++ 先产生一个临时变量_tmpi，记录i(_tmpi)的值用于使用的目的，再给i+1，接着返回这个临时变量。临时变量这个东西，系统认为是个右值
(i++) = 199; //语法错误
```

```c++
int i = 1;
int &&r7 = i++; //成功绑定右值，但是此后r1的值和i没有关系
int &r8 = ++i; //r3绑定到左值i ，r3就变成i的别名了
```

**重点强调**

（1）r7虽然是右值引用（绑定到了右值），但是r1本身它是左值（你要把r1看成一个变量）。因为它在=左边

```c++
int &r9 = r7; //r7是左值
```

（2）所有变量，看成左值，因为它们是有地址的。而且用右值引用也绑定不上

（3）任何函数里面的形参都是左值。 void f(int i, int &&val)

（4）**临时对象都是右值**

### 4.1 引入右值的目的

（a）c++11引用的新概念，&&, 代表一种新数据类型

（b）提高程序运行效率。把拷贝对象编程移动对象来提高程序运行效率

（c）移动对象如何发生。移动构造函数，移动赋值运算符需要 &&

## 五 std::move

c++11标准库里面的新函数

std::move  实际上这个函数根本就没有做移动的操作

std::move的能力只有一个：把一个左值 强制转换成一个右值。带来的结果就是一个右值能绑上去了

```c++
int  i = 10;
int &&r20 = i; 
int &&r20 = std::move(i); //把一个左值转换成一个右值。但是，此时r20就代表i的别名了
i = 20;

int &&ri6 = 100;
int &&ri8 = std::move(ri6); //绑定，代表别名，已经绑定到一起了

std::string st = "I love China";
//string的特殊性，并没有节省内存，只不过是把原有的字符串变为""，原来的是还有地址的
std::string def = std::move(st); //string 里的移动构造函数把st的内容转到def中去了。而不是std::move

std::move(st); //st没有移动，只不过转成了右值
```

