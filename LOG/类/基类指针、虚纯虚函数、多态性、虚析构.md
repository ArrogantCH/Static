# 基类指针、虚纯虚函数、多态性、虚析构

## 五 基类的析构函数一般写成虚函数

```c++
Human *phuman = new Men;
delete phuman; //没有执行子类的析构函数
```

结论：用基类指针 new子类对象，在delete的收系统不会调用派生类的析构函数。这肯定有问题了

如何解决：

在public的继承中，基类对派生类及其对象的操作，只能影响到那些从基类继承下来的成员，如果想要用基类对非继承成员进行操作，则要把基类的这个函数定义为虚函数，析构函数在自然也该如此

另外就是基类中析构函数的虚属性也会被子类继承，这样的话子类中的析构函数也就自然而然的成为了虚函数，虽然名字和基类的名字不一样。

delete phuman的时候，肯定是要调用父类的析构函数，但是在父类的析构函数中它要是想要调用子类Men的析构函数，那么Human这个类中的析构函数就要声明为virtual的，也就是说c++中为了获得运行时的多态行为，所调用的成员函数必须得是virtual的

所以记住：
如果一个类想要做基类，我们必须要把这个累的析构函数写成virtual函数