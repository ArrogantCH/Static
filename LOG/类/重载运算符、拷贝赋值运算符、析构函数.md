# 重载运算符、拷贝赋值运算符、析构函数

## 一 重载运算符

```c++
Time time1;
Time time2;
if (time1 == time2)  //编译报错
{

}
// 两个对象真的不能比较吗，是可以比较的，我们需要“重载==运算符”
// 说白了，我们要写一个成员函数，这个成员函数名 “operator==”, 这个函数体里面，我们要写一些比较逻辑
```

总结：

重载运算符，本质上是一个函数。整个函数的名字：operator关键字 接 运算符

既然重载运算符本质上是一个函数，那么会有返回类型和参数列表

有一些运算符，如果我们不自己写 改运算符的重载，那么系统会自动给我们生成一个。比如赋值运算符的重载

```c++
time2 = time1;
```

## 二 拷贝赋值运算符

```c++
Time myTime;  //调用了构造函数
Time myTime2 = myTime; //调用了拷贝构造函数
Time myTime5 = { myTime }; //调用了拷贝构造函数

Time myTime6; 
myTime6 = myTime5; //这个是赋值运算符，既没有调用构造函数，也没有调用拷贝构造函数
//重载赋值运算符：有返回类型和参数列表，这里的参数就表示运算符的运算对象。比如myTime5就是运算对象
//myTime6就是this对象。myTime5就是operator=里面的参数
```

```c++
Time& operator=(const Time& myTime); //重载的赋值运算符

Time& Time::operator=(const Time &myTime)
{
	hour = myTime.hour;
	minute = myTime.minute;
	second = myTime.second;
	return *this; //返回了自身对象
}
```

## 三 析构函数

相对于构造函数，对象在销毁的时候，会自动调用析构函数

如果不自己定义析构函数，编译器也会生成一个默认的析构函数，函数体为空{}

new/delete 构造函数new出来的，需要在析构函数中销毁

```c++
~Time();
Time::Time()
{
	int *a = new int[100];
}

Time::~Time()
{
	delete [] a;
	std::cout << "调用了析构函数" << std::endl;
}
```

析构函数也是累的成员函数，它的名字是由~接类名构成，没有返回值，不接受任何参数，所以一个类只有一个析构函数

构造函数成员初始化：干了两个事，函数体之前（列表初始化）和函数体之中

析构函数成员的成员销毁：干了两个事，函数体（销毁指针），函数体之后（销毁普通变量）

成员变量的初始化和销毁时机问题：先定义的先初始化，销毁时先定义的后销毁

new对象（调用构造函数）和delete对象（调用析构函数）

new出来的对象，必须总结释放，否则会造成内存泄露