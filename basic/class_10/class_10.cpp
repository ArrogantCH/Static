// class_10.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//
// 基类和派生类的详细再探讨

#include "pch.h"
#include <iostream>
#include "Humen.h"
#include "Men.h"

class A
{
public:
	A(int i) : m_value(i){}
	virtual ~A() {}
private:
	int m_value;

};

class B : public A
{
public:
	B(int i, int j, int k): A(i), m_value(k){} //通过子类的初始化列表给父类的构造函数传递参数
	virtual ~B(){}
private:
	int m_value;
};

int main()
{
	//一：派生类对象模型简述
	Men mymen; //子类（派生类）对象，包含多个组成部分（也就是多个子对象）
	//（1）一个是含有派生类自己定义的成员变量、成员函数的子对象
	//（2）一个是该派生类所继承的基类的子对象，这个子对象中包含的是基类中定义的成员变量，成员函数（派生类对象含有基类对应的组成部分）
	Humen *phuman = new Men; //基类指针可以new派生类对象，因为派生类对象中含有基类部分，所以我们是可以把派生类对象当成基类对象用的
						//换句话说我们可以用基类指针new一个派生类对象
						//编译器帮助我们做了隐式的这种派生类到基类的转换
						//这种转换的好处就是有些需要基类引用的地方你可以用这个派生类对象的引用来代替，如果有些需要基类指针的地方，也可以用派生类对象的指针来代替

	//二 派生类构造函数
	Men myhumen; //既调用基类构造函数，又调用派生类构造函数
	//派生类实际是使用基类的构造函数来初始化它的基类部分。基类控制基类部分的成员初始化，派生类控制派生类部分成员初始化
	//传递参数给基类构造函数问题：通过派生类的构造函数初始化列表

	B(10, 11, 12); //先执行基类的构造函数，再执行派生类的构造函数
					//先执行派生类的西沟函数，再执行派生类的析构函数


	//三 既当父类又当子类
	class gra {};
	class fa : public gra {}; //gra是fa的直接基类
	class son : public fa {}; //gra是son的间接基类（爷爷类）
	//继承关系一直传递，构成了一种继承链，最终结果就是派生类son会包含它的直接基类的成员以及每个间接基类的成员

	//四 不行当基类的类
	//final，加在类名后面，有这个关键字就不能做基类 

	//五 静态类型与动态类型
	Humen *phumen = new Men(); //基类指针指向一个派生类对象
	Humen &q = *phuman; //基类引用绑定到派生类对象上

	//静态类型：变量声明的时候的类型。静态类型编译的时候是已知的
	//动态类型：指的是指针/引用 所代表的（所表达的）内存中的对象的类型。这里是men类型。
			//动态类型 是在运行的时候才能知道
	//动态类型，静态类型这种概念， 只有基类指针/引用 才存在这种静态类型和动态类型不一致的情况
		//如果不是基类的指针/引用，那么静态类型和动态类型永远都是应该一致的
	
	//六 派生类向基类的隐式类型转换。
	Humen *phumen = new Men(); //基类指针指向一个派生类对象
	Humen &q = *phuman; //基类引用绑定到派生类对象上
	//编译器隐式的帮我们执行了派生类到基类的转换。
	//这种转换之所以能够成功，是因为每个派生类对象都包含一个基类对象部分，所以基类的引用或者指针是可以帮到基类对象这部分
	//基类对象 能独立存在，也能作为派生类对象的一部分存在
	
	//并不存在从基类到派生类的自动类型转换
	//Men *pmen = new Humen; //非法

	Humen human;
	//Men &my = human; // 非法,不能将基类转换成派生类（派生类的引用不能绑定到基类对象上去）
	//Men *my = &human; //非法,不能将基类转换成派生类（派生类的指针不能指向基类地址）
	//如果基类中有虚函数的话，可以通过dynamic_cast转换
	Men *my = dynamic_cast<Men *>(&human);
	if (my != nullptr)
	{
		//...
	}

	//七 父类子类之间的拷贝与复制
	Men men; //派生类对象
	Humen human(men); //用派生类对象来定义并初始化基类。这个会导致基类拷贝构造函数的执行
	human = men;

	//结论：
	//用派生类对象为一个基类对象初始化或者赋值时，只有改派生类对象的基类部分会被拷贝或者赋值，派生类部分将被忽略掉
	//也就是基类只干基类自己的事情，多余的部分不会操心
    std::cout << "Hello World!\n"; 
}

